library(XML)

# See MarkLundy/readPDF2HTML.R
# Create the class hierarchy for a document generated by our modified pdftohtml.
setOldClass(c("PDFToHTMLDoc", "ConvertedPDFDoc", "XMLInternalDocument", "XMLAbstractDocument"))
setOldClass(c("PDFToHTMLPage", "ConvertedPDFPage", "XMLInternalElement", "XMLInternalNode", "XMLAbstractNode"))

pdftohtmlDoc =
    #
    # read an XML or a PDF document. If it is XML, it is assumed to be
    # already converted by pdftohtml. If it is a PDF document, we convert it.
    #
function(file)
{
   if(grepl("\\.pdf$", file))
      convertPDF2XML(file)
   else {
      doc = xmlParse(file)
      class(doc) = c("PDFToHTMLDoc", "ConvertedPDFDoc", class(doc))
      doc
   }
}

showPage =
    # toplevel function.  Provide a file and a page number, and we render that page.
function(f, pageNum = 1, doc = xmlParse(f), page = getNodeSet(doc, "//page")[[pageNum]], ...)
{
  if(is(f, "XMLInternalDocument") && missing(doc))
      doc = f
  else if(missing(pageNum) && is(f, "XMLInternalElementNode") && xmlName(f) == "page")
      page = f
  
  renderPage(page, ...)
}

renderPage =
    #
    # Give us the page and we draw its elements - line, rect, img, text
    # The text is not proportional so is often much shorter in the horizontal direction
    # than it would be when displayed as PDF.
    #
function(page, cex.text = 1, adj = c(0, 1), showText = TRUE)
{    
    p = page
    psize = as.integer(xmlAttrs(p)[c("height", "width")])
    h = psize[1]

    plot(0, type = "n", xlab = "", ylab = "", xlim = c(0, psize[2]), ylim = c(0, psize[1]))
    title(sprintf("%s, page %s", docName(page), xmlGetAttr(page, "number")))
    
    rr = getNodeSet(page, ".//rect ")
    if(length(rr)) {
        bb = getBBox(rr)
        col = sapply(rr, function(x) mkColor(xmlGetAttr(x, "fill.color"), isFill = TRUE))
        lwd = max(1, as.numeric(sapply(rr, function(x) xmlGetAttr(x, "lineWidth"))))
        rect(bb[,1], h - bb[,2], bb[,3], h - bb[,4], border = "green", col = col, lwd = lwd)
    }

    if(length ( lines <- getNodeSet(page, ".//line "))) {
        bb = getBBox(lines)
        sapply(1:nrow(bb),
                function(i) {
                     at = xmlAttrs(lines[[i]])
                     lines(bb[i, c(1,3)], h - bb[i, c(2, 4)], col = mkColor(at["stroke.color"]),
                               lwd = max(1, as.numeric(at["lineWidth"])))
                })
        # lines(bb[,1], h - bb[,2], bb[,3], h-bb[,4], col = "red")
    }

    
    imgs = getNodeSet(page, ".//img")
    if(length(imgs)) {
        bb = getBBox2(imgs)
        rect(bb[,1], bb[,2], bb[,3], bb[,4], col = "blue", lty = 3)
    }    

    if(showText) {
        txt = getNodeSet(page, ".//text")
        if(length(txt)) {
            bb = t(sapply(txt, xmlAttrs))
            storage.mode(bb) = "double"
    
            text(bb[,2], h - bb[,1], sapply(txt, xmlValue), cex = cex.text, adj = adj)
        }
    }

    TRUE
}

mkColor =
    # Convert a triple of RGB values as a string into  a color
    # assuming a maxColorValue of 2^16
    # This could be, but is not vectorized.
function(x, alpha = maxColorValue, maxColorValue = 2^16,  isFill = FALSE)
{
   els = as.integer(strsplit(x, ",")[[1]])
   if(isFill && all(els == 0))
       NA
   else
       rgb(els[1], els[2], els[3], alpha, maxColorValue = maxColorValue)
}

getBBox =
    #
    # This bbox function expects an attribute named bbox
    #
function(nodes, asDataFrame = FALSE)
{   
    tmp = sapply(nodes, xmlGetAttr, "bbox")
    els = strsplit(tmp, ",")
    bb = matrix(as.numeric(unlist(els)), , 4, byrow = TRUE)
    colnames(bb) = c("x0", "y0", "x1", "y1")
    if(asDataFrame) 
       as.data.frame(bb)
    else
       bb
}






